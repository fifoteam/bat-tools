//-------------------------------------------------------------------------------------------------
//  -- 版权所有者   : 中国大恒（集团）有限公司北京图像视觉技术分公司, 2010 -2015.
//  -- 保密级别     ：绝密.
//  -- 部门         : 硬件部，FPGA工作组
//  -- 模块名       : chk_pulse_width
//  -- 设计者       : 邢海涛
//-------------------------------------------------------------------------------------------------
//
//  -- 版本记录 :
//
//  -- 作者         :| 修改日期				:|  修改说明
//-------------------------------------------------------------------------------------------------
//  -- 邢海涛       :| 2015/4/14 10:41:05	:|  初始版本
//-------------------------------------------------------------------------------------------------
//
//  -- 模块描述     :
//              1)  : ... ...
//
//              2)  : ... ...
//
//              3)  : ... ...
//
//-------------------------------------------------------------------------------------------------
//仿真单位/精度
`timescale 1ns/1ps
//-------------------------------------------------------------------------------------------------

module chk_pulse_width # (
	parameter		LARGE1_SMALL0		= 0		,	//1-大于等于该脉冲宽度，0-小于等于该脉冲宽度
	parameter		PULSE_POL			= 1		,	//脉冲极性，1-高电平，0-低电平
	parameter		COUNT_WIDHT			= 16	,	//检测计数器的宽度
	parameter		STOP_ON_ERROR		= 1			//出现错误是否停止
	)
	(
	input						clk				,	//时钟
	input						i_chk_en		,	//检测开关
	input						i_din			,	//输入信号
	input	[COUNT_WIDHT-1:0]	iv_pulse_width	,	//脉冲宽度
	output						o_error			//报警信号，提示出现错误。直到使能关闭才会清零
	);

	//	ref signals

	//FSM Parameter Define
	parameter	S_IDLE		= 1'd0;
	parameter	S_PULSE		= 1'd1;

	reg		[0:0]	current_state	= S_IDLE;
	reg		[0:0]	next_state		= S_IDLE;

	//FSM for sim
	// synthesis translate_off
	reg		[63:0]			state_ascii;
	always @ ( * ) begin
		case(current_state)
			1'd0 :	state_ascii	<= "S_IDLE";
			1'd1 :	state_ascii	<= "S_PULSE";
		endcase
	end
	// synthesis translate_on

	reg		[2:0]				din_shift	= 3'b000;
	wire						din_rise	;
	wire						din_fall	;
	wire						first_edge	;
	wire						second_edge	;
	reg		[COUNT_WIDHT-1:0]	pulse_width_cnt	= {COUNT_WIDHT{1'b0}};
	reg							error_reg	= 1'b0;

	//	ref ARCHITECTURE

	//	===============================================================================================
	//	ref ***延时 取边沿***
	//	===============================================================================================
	//	-------------------------------------------------------------------------------------
	//	对输入信号取边沿
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		din_shift	<= {din_shift[1:0],i_din};
	end
	assign	din_rise	= (din_shift[2:1]==2'b01) ? 1'b1 : 1'b0;
	assign	din_fall	= (din_shift[2:1]==2'b10) ? 1'b1 : 1'b0;

	//	-------------------------------------------------------------------------------------
	//	如果是低脉冲，则第一个边沿是下降沿，第二个边沿是上升沿
	//	如果是高脉冲，则第一个边沿是上升沿，第二个边沿是下降沿
	//	-------------------------------------------------------------------------------------
	assign	first_edge	= (PULSE_POL==0 && din_fall==1'b1) ? 1'b1 : ((PULSE_POL==1 && din_rise==1'b1) ? 1'b1 : 1'b0);
	assign	second_edge	= (PULSE_POL==0 && din_rise==1'b1) ? 1'b1 : ((PULSE_POL==1 && din_fall==1'b1) ? 1'b1 : 1'b0);

	//	===============================================================================================
	//	ref ***判断脉冲***
	//	===============================================================================================
	//	-------------------------------------------------------------------------------------
	//	脉宽计数器
	//	-------------------------------------------------------------------------------------
	always @ (posedge clk) begin
		if(current_state==S_IDLE) begin
			pulse_width_cnt	<= {COUNT_WIDHT{1'b0}};
		end
		else begin
			pulse_width_cnt	<= pulse_width_cnt + 1'b1;
		end
	end

	//	-------------------------------------------------------------------------------------
	//	报警信号
	//	1.只有当检查信号取消的时候，才能清零
	//	2.当处于计数状态，且第二个下降沿到来时，判断脉冲
	//	-------------------------------------------------------------------------------------
	generate
		//	-------------------------------------------------------------------------------------
		//	检查宽脉冲
		//	-------------------------------------------------------------------------------------
		if(LARGE1_SMALL0==1) begin
			always @ (posedge clk) begin
				if(!i_chk_en) begin
					error_reg	<= 1'b0;
				end
				if(current_state==S_PULSE && second_edge==1'b1) begin
					if(pulse_width_cnt+1 >= iv_pulse_width) begin
						error_reg	<= 1'b1;
					end
				end
			end
		end
		//	-------------------------------------------------------------------------------------
		//	检查窄脉冲
		//	-------------------------------------------------------------------------------------
		else begin
			always @ (posedge clk) begin
				if(!i_chk_en) begin
					error_reg	<= 1'b0;
				end
				if(current_state==S_PULSE && second_edge==1'b1) begin
					if(pulse_width_cnt+1 <= iv_pulse_width) begin
						error_reg	<= 1'b1;
					end
				end
			end
		end
	endgenerate
	assign	o_error	= error_reg;

	//	-------------------------------------------------------------------------------------
	//	出错处理
	//	-------------------------------------------------------------------------------------
	always @ (posedge error_reg) begin
		$display("%m: at time %t ERROR: pulse width check", $time);
		if(STOP_ON_ERROR) begin
			$stop;
		end
	end

	//	===============================================================================================
	//	ref ***状态机***
	//	===============================================================================================
	//FSM Sequential Logic
	always @ (posedge clk) begin
		if(!i_chk_en) begin
			current_state	<= S_IDLE;
		end else begin
			current_state	<= next_state;
		end
	end

	//FSM Conbinatial Logic
	always @ ( * ) begin
		case(current_state)
			//	-------------------------------------------------------------------------------------
			//	当输入信号的第一个边沿到来时，开始计数
			//	-------------------------------------------------------------------------------------
			S_IDLE	:
			if(first_edge) begin
				next_state	= S_PULSE;
			end
			else begin
				next_state	= S_IDLE;
			end
			//	-------------------------------------------------------------------------------------
			//	当输入信号的第二个边沿到来时，停止计数
			//	-------------------------------------------------------------------------------------
			S_PULSE	:
			if(second_edge) begin
				next_state	= S_IDLE;
			end
			else begin
				next_state	= S_PULSE;
			end
			default	:
			next_state	= S_IDLE;
		endcase
	end





endmodule
